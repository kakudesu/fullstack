---
layout: post
category : lessons

---
{% include JB/setup %}

######类
######继承
######对象
######实例
######类方法
######Virtual
#####多态

1. 对面向对象的理解，不好也可以写程序，但是写不好大程序
2. 对内存的理解
3. 调试的能力
4. 调优的能力

#####const，static

	const int f();//const修饰返回值  
	const int* f();//返回值是int指针，指针所指向的内容不可变
	int* const f();//返回值是int指针，指针本身不可变
	int f() const;//const修饰函数

#####KMP
#####二叉树遍历
#####冒泡排序
#####二分查找
    /*二分查找的基本思想是：（设R[low..high]是当前的查找区间）
    首先确定该区间的中点位置：
    然后将待查的K值与R[mid].key比较：若相等，则查找成功并返回此位置，否则须确定新的查找区间，继续二分查找，具体方法如下：
    若R[mid].key>K，则由表的有序性可知R[mid..n].keys均大于K，因此若表中存在关键字等于K的结点，则该结点必定是在位置mid左边的子表R[1..mid-1]中，故新的查找区间是左子表R[1..mid-1]。
    类似地，若R[mid].key<K，则要查找的K必在mid的右子表R[mid+1..n]中，即新的查找区间是右子表R[mid+1..n]。下一次查找是针对新的查找区间进行的。
    因此，从初始的查找区间R[1..n]开始，每经过一次与当前查找区间的中点位置上的结点关键字的比较，就可确定查找是否成功，不成功则当前的查找区间就缩小一半。这一过程重复直至找到关键字为K的结点，或者直至当前的查找区间为空(即查找失败)时为止。*/

##Swift
* 闭包
* 你使用过Objective-C的运行时编程（Runtime Programming）么？如果使用过，你用它做了什么？你还能记得你所使用的相关的头文件或者某些方法的名称吗？
* 你实现过多线程的Core Data么？NSPersistentStoreCoordinator，NSManagedObjectContext和NSManagedObject中的哪些需要在线程中创建或者传递？你是用什么样的策略来实现的？
* Core开头的系列的内容。是否使用过CoreAnimation和CoreGraphics。UI框架和CA，CG框架的联系是什么？分别用CA和CG做过些什么动画或者图像上的内容。（有需要的话还可以涉及Quartz的一些内容）
* 是否使用过CoreText或者CoreImage等？如果使用过，请谈谈你使用CoreText或者CoreImage的体验。
* NSNotification和KVO的区别和用法是什么？什么时候应该使用通知，什么时候应该使用KVO，它们的实现上有什么区别吗？如果用protocol和delegate（或者delegate的Array）来实现类似的功能可能吗？如果可能，会有什么潜在的问题？如果不能，为什么？（虽然protocol和delegate这种东西面试已经面烂了...）
* 你用过NSOperationQueue么？如果用过或者了解的话，你为什么要使用NSOperationQueue，实现了什么？请描述它和GCD的区别和类似的地方（提示：可以从两者的实现机制和适用范围来描述）。
* 既然提到GCD，那么问一下在使用GCD以及block时要注意些什么？它们两是一回事儿么？block在ARC中和传统的MRC中的行为和用法有没有什么区别，需要注意些什么？
* 您是否做过异步的网络处理和通讯方面的工作？如果有，能具体介绍一些实现策略么？
* 对于Objective-C，你认为它最大的优点和最大的不足是什么？对于不足之处，现在有没有可用的方法绕过这些不足来实现需求。如果可以的话，你有没有考虑或者实践过重新实现OC的一些功能，如果有，具体会如何做？
* 你实现过一个框架或者库以供别人使用么？如果有，请谈一谈构建框架或者库时候的经验；如果没有，请设想和设计框架的public的API，并指出大概需要如何做、需要注意一些什么方面，来使别人容易地使用你的框架。



###[C算法](http://www.codeceo.com/article/10-c-interview-algorithm.html)

#####计算Fibonacci数列  
Fibonacci数列又称斐波那契数列，又称黄金分割数列，指的是这样一个数列：1、1、2、3、5、8、13、21。

C语言实现的代码如下：

    /* Displaying Fibonacci sequence up to nth term where n is entered by user. */
    #include <stdio.h>
    int main()
    {
        int count, n, t1=0, t2=1, display=0;
        printf("Enter number of terms: ");
        scanf("%d",&n);
        printf("Fibonacci Series: %d+%d+", t1, t2); /* Displaying first two terms */
        count=2;    /* count=2 because first two terms are already displayed. */
        while (count<n)
        {
            display=t1+t2;
            t1=t2;
            t2=display;
            ++count;
            printf("%d+",display);
        }
        return 0;
    }
结果输出：

	Enter number of terms: 10
	Fibonacci Series: 0+1+1+2+3+5+8+13+21+34+
也可以使用下面的源代码：

    /* Displaying Fibonacci series up to certain number entered by user. */
    #include <stdio.h>
    int main()
    {
        int t1=0, t2=1, display=0, num;
        printf("Enter an integer: ");
        scanf("%d",&num);
        printf("Fibonacci Series: %d+%d+", t1, t2); /* Displaying first two terms */
        display=t1+t2;
        while(display<num)
        {
            printf("%d+",display);
            t1=t2;
            t2=display;
            display=t1+t2;
        }
        return 0;
    }
结果输出：

	Enter an integer: 200
	Fibonacci Series: 0+1+1+2+3+5+8+13+21+34+55+89+144+

##### 回文检查
源代码：

    /* C program to check whether a number is palindrome or not */
    #include <stdio.h>
    int main()
    {
        int n, reverse=0, rem,temp;
        printf("Enter an integer: ");
        scanf("%d", &n);
        temp=n;
        while(temp!=0)
        {
            rem=temp%10;
            reverse=reverse*10+rem;
            temp/=10;
        }
        /* Checking if number entered by user and it's reverse number is equal. */
        if(reverse==n)
            printf("%d is a palindrome.",n);
        else
            printf("%d is not a palindrome.",n);
        return 0;
    }

结果输出：

	Enter an integer: 12321
	12321 is a palindrome.

#####质数检查
注：1既不是质数也不是合数。
源代码：

    /* C program to check whether a number is prime or not. */
    #include <stdio.h>
    int main()
    {
        int n, i, flag=0;
        printf("Enter a positive integer: ");
        scanf("%d",&n);
        for(i=2;i<=n/2;++i)
        {
            if(n%i==0)
            {
                flag=1;
                break;
            }
        }
        if (flag==0)
            printf("%d is a prime number.",n);
        else
            printf("%d is not a prime number.",n);
        return 0;
    }
结果输出：

	Enter a positive integer: 29
	29 is a prime number.
####打印金字塔和三角形
使用 * 建立三角形

    #include <stdio.h>
    int main()
    {
        int i,j,rows;
        printf("Enter the number of rows: ");
        scanf("%d",&rows);
        for(i=1;i<=rows;++i)
        {
            for(j=1;j<=i;++j)
            {
                printf("* ");
            }
            printf("\n");
        }
        return 0;
    }
使用数字打印半金字塔。
源代码：

    #include <stdio.h>
    int main()
    {
        int i,j,rows;
        printf("Enter the number of rows: ");
        scanf("%d",&rows);
        for(i=1;i<=rows;++i)
        {
            for(j=1;j<=i;++j)
            {
                printf("%d ",j);
            }
            printf("\n");
        }
        return 0;
    }
用 * 打印倒半金字塔

    #include <stdio.h>
    int main()
    {
        int i,j,rows;
        printf("Enter the number of rows: ");
        scanf("%d",&rows);
        for(i=rows;i>=1;--i)
        {
            for(j=1;j<=i;++j)
            {
                printf("* ");
            }
            printf("\n");
        }
        return 0;
    }

用 * 打印金字塔

    #include <stdio.h>
    int main()
    {
        int i,space,rows,k=0;
        printf("Enter the number of rows: ");
        scanf("%d",&rows);
        for(i=1;i<=rows;++i)
        {
            for(space=1;space<=rows-i;++space)
            {
                printf("  ");
            }
            while(k!=2*i-1)
            {
                printf("* ");
                ++k;
            }
            k=0;
            printf("\n");
        }
        return 0;
    }
用 * 打印倒金字塔

    #include<stdio.h>
    int main()
    {
        int rows,i,j,space;
        printf("Enter number of rows: ");
        scanf("%d",&rows);
        for(i=rows;i>=1;--i)
        {
            for(space=0;space<rows-i;++space)
                printf("  ");
            for(j=i;j<=2*i-1;++j)
                printf("* ");
            for(j=0;j<i-1;++j)
                printf("* ");
            printf("\n");
        }
        return 0;
    }
####简单的加减乘除计算器

    /* Source code to create a simple calculator for addition, subtraction, multiplication and division using switch...case statement in C programming. */
    # include <stdio.h>
    int main()
    {
        char o;
        float num1,num2;
        printf("Enter operator either + or - or * or divide : ");
        scanf("%c",&o);
        printf("Enter two operands: ");
        scanf("%f%f",&num1,&num2);
        switch(o) {
            case '+':
                printf("%.1f + %.1f = %.1f",num1, num2, num1+num2);
                break;
            case '-':
                printf("%.1f - %.1f = %.1f",num1, num2, num1-num2);
                break;
            case '*':
                printf("%.1f * %.1f = %.1f",num1, num2, num1*num2);
                break;
            case '/':
                printf("%.1f / %.1f = %.1f",num1, num2, num1/num2);
                break;
            default:
                /* If operator is other than +, -, * or /, error message is shown */
                printf("Error! operator is not correct");
                break;
        }
        return 0;
    }
结果输出：

	Enter operator either + or - or * or divide : -
	Enter two operands: 3.4
	8.4
	3.4 - 8.4 = -5.0
#####检查一个数能不能表示成两个质数之和
    #include <stdio.h>
    int prime(int n);
    int main()
    {
        int n, i, flag=0;
        printf("Enter a positive integer: ");
        scanf("%d",&n);
        for(i=2; i<=n/2; ++i)
        {
            if (prime(i)!=0)
            {
                if ( prime(n-i)!=0)
                {
                    printf("%d = %d + %d\n", n, i, n-i);
                    flag=1;
                }
                
            }
        }
        if (flag==0)
            printf("%d can't be expressed as sum of two prime numbers.",n);
        return 0;
    }
    int prime(int n)      /* Function to check prime number */
    {
        int i, flag=1;
        for(i=2; i<=n/2; ++i)
            if(n%i==0)
                flag=0;
        return flag;
    }
结果输出：

	Enter a positive integer: 34
	34 = 3 + 31
	34 = 5 + 29
	34 = 11 + 23
	34 = 17 + 17
#####用递归的方式颠倒字符串
    /* Example to reverse a sentence entered by user without using strings. */
    #include <stdio.h>
    void Reverse();
    int main()
    {
        printf("Enter a sentence: ");
        Reverse();
        return 0;
    }
    void Reverse()
    {
        char c;
        scanf("%c",&c);
        if( c != '\n')
        {
            Reverse();
            printf("%c",c);
        }
    }
结果输出：

	Enter a sentence: margorp emosewa
	awesome program
#####实现二进制与十进制之间的相互转换
    /* C programming source code to convert either binary to decimal or decimal to binary according to data entered by user. */
    #include <stdio.h>
    #include <math.h>
    int binary_decimal(int n);
    int decimal_binary(int n);
    int main()
    {
        int n;
        char c;
        printf("Instructions:\n");
        printf("1. Enter alphabet 'd' to convert binary to decimal.\n");
        printf("2. Enter alphabet 'b' to convert decimal to binary.\n");
        scanf("%c",&c);
        if (c =='d' || c == 'D')
        {
            printf("Enter a binary number: ");
            scanf("%d", &n);
            printf("%d in binary = %d in decimal", n, binary_decimal(n));
        }
        if (c =='b' || c == 'B')
        {
            printf("Enter a decimal number: ");
            scanf("%d", &n);
            printf("%d in decimal = %d in binary", n, decimal_binary(n));
        }
        return 0;
    }
    int decimal_binary(int n)  /* Function to convert decimal to binary.*/
    {
        int rem, i=1, binary=0;
        while (n!=0)
        {
            rem=n%2;
            n/=2;
            binary+=rem*i;
            i*=10;
        }
        return binary;
    }
    int binary_decimal(int n) /* Function to convert binary to decimal.*/
    
    {
        int decimal=0, i=0, rem;
        while (n!=0)
        {
            rem = n%10;
            n/=10;
            decimal += rem*pow(2,i);
            ++i;
        }
        return decimal;
    }
#####使用多维数组实现两个矩阵的相加

    #include <stdio.h>
    int main(){
        int r,c,a[100][100],b[100][100],sum[100][100],i,j;
        printf("Enter number of rows (between 1 and 100): ");
        scanf("%d",&r);
        printf("Enter number of columns (between 1 and 100): ");
        scanf("%d",&c);
        printf("\nEnter elements of 1st matrix:\n");
        
        /* Storing elements of first matrix entered by user. */
        
        for(i=0;i<r;++i)
            for(j=0;j<c;++j)
            {
                printf("Enter element a%d%d: ",i+1,j+1);
                scanf("%d",&a[i][j]);
            }
        
        /* Storing elements of second matrix entered by user. */
        
        printf("Enter elements of 2nd matrix:\n");
        for(i=0;i<r;++i)
            for(j=0;j<c;++j)
            {
                printf("Enter element a%d%d: ",i+1,j+1);
                scanf("%d",&b[i][j]);
            }
        
        /*Adding Two matrices */
        
        for(i=0;i<r;++i)
            for(j=0;j<c;++j)
                sum[i][j]=a[i][j]+b[i][j];
        
        /* Displaying the resultant sum matrix. */
        
        printf("\nSum of two matrix is: \n\n");
        for(i=0;i<r;++i)
            for(j=0;j<c;++j)
            {
                printf("%d   ",sum[i][j]);
                if(j==c-1)
                    printf("\n\n");
            }
        
        return 0;
    }
#####矩阵转置

    #include <stdio.h>
    int main()
    {
        int a[10][10], trans[10][10], r, c, i, j;
        printf("Enter rows and column of matrix: ");
        scanf("%d %d", &r, &c);
        
        /* Storing element of matrix entered by user in array a[][]. */
        printf("\nEnter elements of matrix:\n");
        for(i=0; i<r; ++i)
            for(j=0; j<c; ++j)
            {
                printf("Enter elements a%d%d: ",i+1,j+1);
                scanf("%d",&a[i][j]);
            }
        /* Displaying the matrix a[][] */
        printf("\nEntered Matrix: \n");
        for(i=0; i<r; ++i)
            for(j=0; j<c; ++j)
            {
                printf("%d  ",a[i][j]);
                if(j==c-1)
                    printf("\n\n");
            }
        
        /* Finding transpose of matrix a[][] and storing it in array trans[][]. */
        for(i=0; i<r; ++i)
            for(j=0; j<c; ++j)
            {
                trans[j][i]=a[i][j];
            }
        
        /* Displaying the transpose,i.e, Displaying array trans[][]. */
        printf("\nTranspose of Matrix:\n");
        for(i=0; i<c; ++i)
            for(j=0; j<r; ++j)
            {
                printf("%d  ",trans[i][j]);
                if(j==r-1)
                    printf("\n\n");
            }
        return 0;
    }

##[c++概念](http://liu-mengmeng.diandian.com/post/2013-05-09/40050161491)
#####static与const的区别与作用

    /*const定义的变量在函数执行完毕后其空间会被释放；static定义的静态变量在函数执行后其空间不会被释放。
     static表示的是静态的。类的静态变量，静态成员函数是和类相关，而不是和类的对象相关的，即使没有具体的对象，也可以调用类的静态变量，静态成员函数。
     在c++中，static静态成员变量不能在类内部初始化；const成员常量不能再类定义处初始化，只能通过构造函数的初始化列表进行，并且必须有构造函数。
     const数据成员只在类的对象生存期内是常量，而对于整个类而言却是可变的。因为类可以创建多个对象，不同的对象，其const数据成员的值可以不同。所以不能在类的声明中初始化const数据成员，因为类的对象未被创建时，编译器不知道const数据成员的值是什么。
     */
    const int f();//const修饰返回值
    const int* f();//返回值是int指针，指针所指向的内容不可变
    int* const f();//返回值是int指针，指针本身不可变
    int f() const;//const修饰函数
    
    /*const数据成员的初始化只能在类的构造函数的初始化表中进行。要想建立在整个类中都恒定的常量，应该用类中的枚举常量来实现，或者static  const*/
    classTest
    {
    public:
        　　Test():a(0){}
        　　  enum {size1=100, size2 = 200 };
    private:
        　　const int a;  //只能在构造函数初始化列表中初始化
        　　static int b；
        　　const static int c; //与static const intc;相同
    }
    
    /*int Test：：b = 0; //不能以成员列表初始化，不能在定义处初始化，因为不属于某个对象
     const int Test：：c＝0；//注意：给静态成员变量赋值时，不在需要加static修饰。但const要加*/
    //static成员的初始化
    class foo
    {
        private：
        static int i;
        public：
        foo()；
    };
    int foo：：i = 100；
    
    /*static成员的初试化在类体外进行，而前面不加static，以免与一般的静态变量相混淆。
     初试化时使用作用域运算符来表明它所属的类，说明静态数据成员是类的成员，而不是对象的成员。*/
    //const static成员/static const成员的初始化
    class Test{
        　　　　  public：
        　　　　　　　　static const int MASK1;
        　　　　　　　　const static int MASK2;
        　　　　  };
    const int Test：：MASK1 = 0xFFFF;
    const int Test：：MASK2 = 0xFFFF;
    //const static与static const是一样的。
    
    /*const成员要在构造函数初始化列表初始化，而static成员则需要在类体外初始化，那么const static呢？
     应该在类体外初试化，加上const修饰符，与作用域运算符：const int Test::MASK1 = oxFFFF;
     const成员函数，是为了防止修改对象的内容，可以访问对象的数据，访问成员函数时，只能是const的，不能是non_const的成员函数。
     static成员函数，主要的目的是作为类作用域的全局函数，不能访问类的非静态数据成员。类的静态成员函数没有this指针，这导致：不能直接存取类的非静态成员变量，不能调用非静态成员函数，不能被声明为virtual。*/
#####程序的编译、链接、运行期各执行了哪些操作？

    /*编译--编译之前其实有一个预处理阶段，就是根据文件中的预处理指令修改源文件的内容，比如#include指令就是一个预处理指令，它把头文件的内容添加到.cpp文件中(还有其他许多预处理指令)。之后才是编译代码，编译器检查代码，为给定源文件输出机器码，这个时候并没有在对象文件之间建立任何连接，也没有建立同库函数的链接。
    链接--把所有对象文件中的机器码组合在一起，解析他们之间的交叉引用。还集成了对象模块所使用的库函数的代码。这是链接程序的一种简化表示，因为这里假定在可执行模块中，模块之间的所有链接都是静态建立的，实际上有些链接是动态的，即这些链接是在程序执行时建立的。
    运行--执行程序。*/

#####static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？
1. 作用域不用，普通全局是整个源程序，而静态全局变量在定义的源文件种。
2. 静态全局变量，函数运行完变量的值不释放，下次调用保留推出时候的值，而普通变量值释放
3. 只在当前源文件中使用的函数应该说明为内部函数(static)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件。

#####局部变量能否和全局变量重名？说明他们的作用域。

    可以重名，局部变量在这个函数起作用，全局变量整个源文件有效，
    在函数内局部变量有效，全局无效*/    
#####某媒体说“南京长江大桥日均通车总量在100万量左右（双向通行的车辆都含在内）”。你觉得这个数据可信吗？说说你的理由。

	不可能。一天=24*3600s*2=172800s。一秒一辆才能通过17万多辆。100万是不可能的
	UNION是一个联合体，各个成员共用空间，占用的空间等于其中占用空间最大的成员的SIZE。
#####关于引用：
* 声明时须初始化；
* 不能把引用名作为其他变量名的别名；
* 引用不占用内存单元；
* 不能建立数组的引用
* 引用作为参数：
* 被调函数的形参成为主调函数中实参变量或对象的别名，在被调函数中对形参变量的操作就是对其相应的主调函数的实参变量或对象的操作
* 使用引用传递函数的参数，在内存中没有产生实参的副本，它是直接对实参操作。而使用一般变量传递函数的参数时，需要给形参分配存储单元，形参是实参的副本；如果传递的是对象，还需调用拷贝构造函数。因此，当参数传递的数据较大时，引用比一般变量传递参数效率和节省空间
* 相比于指针，指针在被调函数中同样要给形参分配存储单元。在主调函数的调用点处，必须使用变量的地址作为实参。引用比指针更具可读性。

#####UML中关联、聚合、组合

    /*Association关联关系表现为变量(has a )。类与类之间的联接，它使一个类知道另一个类的属性和方法。例如如果A依赖于B，则B体现为A的全局变量。关联关系有双向关联和单向关联。双向关联：两个类都知道另一个类的公共属性和操作。单向关联：只有一个类知道另外一个类的公共属性和操作。大多数关联应该是单向的，单向关系更容易建立和维护，有助于寻找可服用的类。
    Aggregation(聚合关系) 是关联关系的一种，是强的关联关系。聚合关系是整体和个体的关系。普通关联关系的两个类处于同一层次上，而聚合关系的两个类处于不同的层次，一个是整体，一个是部分。同时，是一种弱的“拥有”关系。体现的是A对象可以包含B对象，但B对象不是A对象的组成部分。具体表现为，如果A由B聚合成，表现为A包含有B的全局对象，但是B对象可以不在A创建的时刻创建。
    Composition(组合关系)是关联关系的一种，是比聚合关系强的关系。它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。Composition(组合关系)是一种强的“拥有”关系，体现了严格的部分和整体的关系，部分和整体的生命周期一致。如果A由B组成，表现为A包含有B的全局对象，并且B对象在A创建的时刻创建。*/

#####只能用intializationlist 而不能用assignment

	当类中含有const、reference 成员变量；基类的构造函数都需要初始化表。
#####C++是不是类型安全的

	不是。两个不同类型的指针之间可以强制转换（用reinterpret cast)。C#是类型安全的。
#####函数执行以前，还会执行什么代码

	全局对象的构造函数会在main 函数之前执行，为malloc分配必要的资源，等等。

#####当一个类A 中没有生命任何成员变量与成员函数,这时sizeof(A)的值是多少(1bytes)，如果不是零，请解释一下编译器为什么没有让它为零。（Autodesk）
	肯定不是零。举个反例，如果是零的话，声明一个class A[10]对象数组，而每一个对象占用的空间是零，这时就没办法区分A[0],A[1]…了。
#####在8086 汇编下，逻辑地址和物理地址是怎样转换的？（Intel）
	通用寄存器给出的地址，是段内偏移地址，相应段寄存器地址*10H+通用寄存器内地址，就得到了真正要访问的地址。
#####打印出当前源文件的文件名以及源文件的当前行号

	cout << __FILE__ ;
	cout<<__LINE__ ;
	>__FILE__和__LINE__是系统预定义宏，这种宏并不是在某个文件中定义的，而是由编译器定义的
#####main 主函数执行完毕后，再执行一段代码
	
	/*可以，可以用_onexit 注册一个函数，它会在main 之后执行*/
    int fn1(void), fn2(void), fn3(void),fn4 (void);
    void main( void ){
        String str("zhanglin");
        _onexit( fn1 );
        　　_onexit( fn2 );
        　　_onexit( fn3 );
        　　_onexit( fn4 );
        　　printf( "This is executed first.\n" );
    }
    int fn1()
    {
        　　printf( "next.\n" );
        　	　return0;
    }
    int fn2()
    {
        　　printf( "executed " );
        　	　return0;
    }
    int fn3()
    {
        　　printf( "is " );
        　	　return0;
    }
    int fn4()
    {
        　　printf( "This " );
        　　return0;
    }

#####判断一段程序是由C 编译程序还是由C++编译程序编译的

	#ifdef __cplusplus
	#define USING_C 0
	#else
	#define USING_C 1 
	#endif
	
#####下面代码错误
    swap( int* p1,int* p2 )
    {
        　int *p;
        　*p = *p1;
        　*p1 = *p2;
        　*p2 = *p;
    }
在swap函数中，p是一个“野”指针，有可能指向系统区，导致程序运行的崩溃。在VC++中DEBUG运行时提示错误“AccessViolation”。该程序应该改为：
    
    swap( int* p1,int* p2 )
    {
        　int p;
        　p = *p1;
        　*p1 = *p2;
        　*p2 = p;
    }
#####BOOL，int，float，指针变量 与“零值”比较的 if 语句（假设变量名为var）

	BOOL型变量：if(!var)
	int型变量：if(var==0)
	float型变量：
	const float EPSINON = 0.00001;
	if ((x >= - EPSINON) && (x <=EPSINON)	
	指针变量：　　if(var==NULL)
#####数组名可以转换为指向其指代实体的指针，而且是一个指针常量，不能作自增、自减等操作，不能被修改；
	char str[10]; 
	str++; //编译出错，提示str不是左值　

#####static和const关键字的作用
######Static
1. 函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；
2. 在模块内的static全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；
3. 在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；
4. 在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；
5. 在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。

######Const
1. 欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；
2. 对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；
3. 在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；
4. 对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量；(const修饰类的成员函数，修饰的是类对象的实参this，表示不能改变this的值；但是如果类成员函数声明为static，则该函数就不接受this指针，此时该函数就不能同时声明为const)
5. 对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。例如：
const classA operator*(const classA& a1,const classA& a2);
　　operator*的返回结果必须是一个const对象。如果不是，这样的变态代码也不会编译出错：
classA a, b, c;
(a * b) = c; // 对a*b的结果赋值
　　操作(a * b) = c显然不符合编程者的初衷，也没有任何意义。
